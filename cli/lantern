#!/usr/bin/env bash
# ============================================================================
# Lantern CLI — thin wrapper around the Lantern daemon API
# A "Valet for Linux" dev environment manager
# ============================================================================

set -euo pipefail

readonly LANTERN_VERSION="0.1.0"
readonly LANTERN_HOST="${LANTERN_HOST:-http://127.0.0.1:4777}"
readonly LANTERN_API="${LANTERN_HOST}/api"

# ---------------------------------------------------------------------------
# Colors & formatting
# ---------------------------------------------------------------------------

if [[ -t 1 ]] && [[ "${NO_COLOR:-}" == "" ]]; then
    readonly C_RESET='\033[0m'
    readonly C_BOLD='\033[1m'
    readonly C_DIM='\033[2m'
    readonly C_RED='\033[0;31m'
    readonly C_GREEN='\033[0;32m'
    readonly C_YELLOW='\033[0;33m'
    readonly C_BLUE='\033[0;34m'
    readonly C_MAGENTA='\033[0;35m'
    readonly C_CYAN='\033[0;36m'
    readonly C_WHITE='\033[0;37m'
    readonly C_BOLD_RED='\033[1;31m'
    readonly C_BOLD_GREEN='\033[1;32m'
    readonly C_BOLD_YELLOW='\033[1;33m'
    readonly C_BOLD_BLUE='\033[1;34m'
    readonly C_BOLD_CYAN='\033[1;36m'
    readonly C_BOLD_WHITE='\033[1;37m'
else
    readonly C_RESET='' C_BOLD='' C_DIM=''
    readonly C_RED='' C_GREEN='' C_YELLOW='' C_BLUE='' C_MAGENTA='' C_CYAN='' C_WHITE=''
    readonly C_BOLD_RED='' C_BOLD_GREEN='' C_BOLD_YELLOW='' C_BOLD_BLUE='' C_BOLD_CYAN='' C_BOLD_WHITE=''
fi

# Status indicators
readonly ICON_OK="${C_GREEN}●${C_RESET}"
readonly ICON_ERR="${C_RED}●${C_RESET}"
readonly ICON_WARN="${C_YELLOW}●${C_RESET}"
readonly ICON_OFF="${C_DIM}○${C_RESET}"
readonly ICON_SPIN="${C_CYAN}◌${C_RESET}"
readonly ICON_ARROW="${C_CYAN}▸${C_RESET}"

# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------

info()    { echo -e "${C_BOLD_BLUE}info${C_RESET}  $*"; }
success() { echo -e "${C_BOLD_GREEN}ok${C_RESET}    $*"; }
warn()    { echo -e "${C_BOLD_YELLOW}warn${C_RESET}  $*" >&2; }
error()   { echo -e "${C_BOLD_RED}error${C_RESET} $*" >&2; }
die()     { error "$@"; exit 1; }

# Check if a command exists
need_cmd() {
    if ! command -v "$1" &>/dev/null; then
        die "Required command '${1}' not found. Please install it first."
    fi
}

# Check daemon connectivity (fast check)
check_daemon() {
    local http_code
    http_code=$(curl -s -o /dev/null -w '%{http_code}' --connect-timeout 2 "${LANTERN_API}/system/health" 2>/dev/null) || true

    if [[ "$http_code" == "000" ]]; then
        echo ""
        error "Cannot connect to Lantern daemon at ${LANTERN_HOST}"
        echo -e "  ${C_DIM}Is the daemon running? Start it with:${C_RESET}"
        echo -e "  ${C_BOLD}  sudo systemctl start lantern${C_RESET}"
        echo -e "  ${C_DIM}Or run in development mode:${C_RESET}"
        echo -e "  ${C_BOLD}  cd daemon && mix phx.server${C_RESET}"
        echo ""
        exit 1
    fi
}

# ---------------------------------------------------------------------------
# API functions
# ---------------------------------------------------------------------------

# Raw API call — returns JSON body, sets $HTTP_CODE
api_raw() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"
    local tmpfile

    tmpfile=$(mktemp)
    trap "rm -f '$tmpfile'" RETURN

    local curl_args=(
        -s
        -w '\n%{http_code}'
        -X "$method"
        -H "Content-Type: application/json"
        -H "Accept: application/json"
        --connect-timeout 5
        --max-time 30
    )

    if [[ -n "$data" ]]; then
        curl_args+=(-d "$data")
    fi

    curl_args+=("${LANTERN_API}${endpoint}")

    local response
    response=$(curl "${curl_args[@]}" 2>/dev/null) || {
        die "Failed to connect to daemon at ${LANTERN_HOST}"
    }

    HTTP_CODE=$(echo "$response" | tail -n1)
    RESPONSE_BODY=$(echo "$response" | sed '$d')
}

# API call with error handling — prints formatted output
api() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"

    api_raw "$method" "$endpoint" "$data"

    if [[ "$HTTP_CODE" -ge 400 ]]; then
        local err_msg
        err_msg=$(echo "$RESPONSE_BODY" | jq -r '.message // .error // "Unknown error"' 2>/dev/null) || err_msg="HTTP ${HTTP_CODE}"
        die "$err_msg"
    fi

    echo "$RESPONSE_BODY"
}

# API call that returns just the body (no jq formatting)
api_quiet() {
    local method="$1"
    local endpoint="$2"
    local data="${3:-}"

    api_raw "$method" "$endpoint" "$data"

    if [[ "$HTTP_CODE" -ge 400 ]]; then
        return 1
    fi

    echo "$RESPONSE_BODY"
}

# Pretty-print JSON with jq if available, otherwise raw
json_pp() {
    if command -v jq &>/dev/null; then
        jq '.' 2>/dev/null || cat
    else
        cat
    fi
}

# ---------------------------------------------------------------------------
# Commands
# ---------------------------------------------------------------------------

cmd_init() {
    info "Running one-time system setup..."
    echo ""

    local result
    result=$(api POST /system/init)

    # Parse and display results
    local dns caddy tls
    dns=$(echo "$result" | jq -r '.data.dns // "unknown"' 2>/dev/null)
    caddy=$(echo "$result" | jq -r '.data.caddy // "unknown"' 2>/dev/null)
    tls=$(echo "$result" | jq -r '.data.tls // "unknown"' 2>/dev/null)

    echo -e "  DNS (dnsmasq)  $(status_icon "$dns") ${dns}"
    echo -e "  Caddy          $(status_icon "$caddy") ${caddy}"
    echo -e "  TLS            $(status_icon "$tls") ${tls}"
    echo ""

    if [[ "$dns" == "ok" && "$caddy" == "ok" && "$tls" == "ok" ]]; then
        success "System initialized successfully!"
        echo -e "  ${C_DIM}Next: run ${C_BOLD}lantern scan${C_RESET}${C_DIM} to detect your projects${C_RESET}"
    else
        warn "Some components may need attention. Run ${C_BOLD}lantern health${C_RESET} for details."
    fi
}

cmd_scan() {
    info "Scanning workspace for projects..."
    echo ""

    local result
    result=$(api POST /projects/scan)

    local total new_count
    total=$(echo "$result" | jq -r '.meta.total // .meta.count // (.data | length) // 0' 2>/dev/null)
    new_count=$(echo "$result" | jq -r '.meta.new // .meta.new_count // 0' 2>/dev/null)

    success "Found ${C_BOLD}${total}${C_RESET} projects (${new_count} new)"
    echo ""

    # Show detected projects
    echo "$result" | jq -r '.data[]? | "  \(.name)\t\(.type)\t\(.detection.confidence // "unknown")"' 2>/dev/null | \
    while IFS=$'\t' read -r name type confidence; do
        local type_badge
        type_badge=$(type_badge "$type")
        echo -e "  ${ICON_ARROW} ${C_BOLD}${name}${C_RESET}  ${type_badge}  ${C_DIM}(${confidence})${C_RESET}"
    done

    echo ""
    echo -e "  ${C_DIM}Activate a project: ${C_BOLD}lantern on <name>${C_RESET}"
}

cmd_list() {
    check_daemon

    local result
    result=$(api GET /projects)

    local count
    count=$(echo "$result" | jq -r '.data | length' 2>/dev/null) || count=0

    if [[ "$count" == "0" ]]; then
        warn "No projects found. Run ${C_BOLD}lantern scan${C_RESET} first."
        return 0
    fi

    echo ""
    echo -e "  ${C_BOLD}Projects${C_RESET} (${count})"
    echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"
    echo ""

    echo "$result" | jq -r '.data[]? | "\(.name)\t\(.domain)\t\(.type)\t\(.status)"' 2>/dev/null | \
    while IFS=$'\t' read -r name domain type status; do
        local icon type_badge
        icon=$(status_icon "$status")
        type_badge=$(type_badge "$type")
        printf "  %b  %-20s %b  %-25s %b\n" "$icon" "$name" "${C_DIM}" "${domain}" "${C_RESET}"
    done

    echo ""
}

cmd_on() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        die "Usage: lantern on <project-name>"
    fi

    check_daemon

    info "Activating ${C_BOLD}${name}${C_RESET}..."

    local result
    result=$(api POST "/projects/${name}/activate")

    local domain status
    domain=$(echo "$result" | jq -r '.data.domain // "unknown"' 2>/dev/null)
    status=$(echo "$result" | jq -r '.data.status // "unknown"' 2>/dev/null)

    echo ""
    success "${C_BOLD}${name}${C_RESET} is now active"
    echo -e "  ${ICON_ARROW} ${C_BOLD_CYAN}https://${domain}${C_RESET}"

    local run_cmd
    run_cmd=$(echo "$result" | jq -r '.data.run_cmd // empty' 2>/dev/null)
    if [[ -n "$run_cmd" ]]; then
        echo -e "  ${ICON_ARROW} Dev server: ${C_DIM}${run_cmd}${C_RESET}"
    fi
    echo ""
}

cmd_off() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        die "Usage: lantern off <project-name>"
    fi

    check_daemon

    info "Deactivating ${C_BOLD}${name}${C_RESET}..."

    api POST "/projects/${name}/deactivate" >/dev/null

    success "${C_BOLD}${name}${C_RESET} has been deactivated"
}

cmd_restart() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        die "Usage: lantern restart <project-name>"
    fi

    check_daemon

    info "Restarting ${C_BOLD}${name}${C_RESET}..."

    local result
    result=$(api POST "/projects/${name}/restart")

    local domain
    domain=$(echo "$result" | jq -r '.data.domain // "unknown"' 2>/dev/null)

    success "${C_BOLD}${name}${C_RESET} restarted"
    echo -e "  ${ICON_ARROW} ${C_BOLD_CYAN}https://${domain}${C_RESET}"
}

cmd_status() {
    local name="${1:-}"

    check_daemon

    if [[ -z "$name" ]]; then
        # Global status overview
        cmd_status_global
    else
        # Per-project status
        cmd_status_project "$name"
    fi
}

cmd_status_global() {
    local projects health

    projects=$(api_quiet GET /projects) || projects='{"data":[]}'
    health=$(api_quiet GET /system/health) || health='{"data":{}}'

    echo ""
    echo -e "  ${C_BOLD}Lantern${C_RESET} v${LANTERN_VERSION}"
    echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"

    # System health
    local dns caddy tls
    dns=$(echo "$health" | jq -r '.data.dns.status // "unknown"' 2>/dev/null)
    caddy=$(echo "$health" | jq -r '.data.caddy.status // "unknown"' 2>/dev/null)
    tls=$(echo "$health" | jq -r '.data.tls.status // "unknown"' 2>/dev/null)

    echo ""
    echo -e "  ${C_BOLD}System${C_RESET}"
    echo -e "    DNS     $(status_icon "$dns") ${dns}"
    echo -e "    Caddy   $(status_icon "$caddy") ${caddy}"
    echo -e "    TLS     $(status_icon "$tls") ${tls}"

    # Active projects
    local running stopped total
    total=$(echo "$projects" | jq -r '.data | length' 2>/dev/null) || total=0
    running=$(echo "$projects" | jq -r '[.data[]? | select(.status == "running")] | length' 2>/dev/null) || running=0
    stopped=$(echo "$projects" | jq -r '[.data[]? | select(.status == "stopped")] | length' 2>/dev/null) || stopped=0

    echo ""
    echo -e "  ${C_BOLD}Projects${C_RESET}  ${total} total, ${C_GREEN}${running} running${C_RESET}, ${C_DIM}${stopped} stopped${C_RESET}"

    if [[ "$running" -gt 0 ]]; then
        echo ""
        echo "$projects" | jq -r '.data[]? | select(.status == "running") | "\(.name)\t\(.domain)"' 2>/dev/null | \
        while IFS=$'\t' read -r name domain; do
            echo -e "    ${ICON_OK} ${name}  ${C_DIM}→  https://${domain}${C_RESET}"
        done
    fi

    echo ""
}

cmd_status_project() {
    local name="$1"

    local result
    result=$(api GET "/projects/${name}")

    local pname domain type status port run_cmd path
    pname=$(echo "$result" | jq -r '.data.name // "unknown"' 2>/dev/null)
    domain=$(echo "$result" | jq -r '.data.domain // "unknown"' 2>/dev/null)
    type=$(echo "$result" | jq -r '.data.type // "unknown"' 2>/dev/null)
    status=$(echo "$result" | jq -r '.data.status // "unknown"' 2>/dev/null)
    port=$(echo "$result" | jq -r '.data.port // "—"' 2>/dev/null)
    run_cmd=$(echo "$result" | jq -r '.data.run_cmd // "—"' 2>/dev/null)
    path=$(echo "$result" | jq -r '.data.path // "unknown"' 2>/dev/null)

    echo ""
    echo -e "  ${C_BOLD}${pname}${C_RESET}  $(status_icon "$status") ${status}"
    echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"
    echo ""
    echo -e "  Domain    ${C_BOLD_CYAN}https://${domain}${C_RESET}"
    echo -e "  Type      $(type_badge "$type")"
    echo -e "  Path      ${C_DIM}${path}${C_RESET}"
    echo -e "  Port      ${port}"
    echo -e "  Command   ${C_DIM}${run_cmd}${C_RESET}"

    # Features
    local mailpit
    mailpit=$(echo "$result" | jq -r '.data.features.mailpit // false' 2>/dev/null)
    if [[ "$mailpit" == "true" ]]; then
        echo -e "  Mailpit   ${ICON_OK} enabled"
    fi

    echo ""
}

cmd_logs() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        die "Usage: lantern logs <project-name>"
    fi

    check_daemon

    info "Streaming logs for ${C_BOLD}${name}${C_RESET}... (Ctrl+C to stop)"
    echo ""

    # Use SSE (Server-Sent Events) for streaming logs
    # Fall back to polling if SSE is not available
    curl -s -N \
        -H "Accept: text/event-stream" \
        "${LANTERN_API}/projects/${name}/logs" 2>/dev/null | \
    while IFS= read -r line; do
        # Parse SSE format: lines starting with "data: "
        if [[ "$line" == data:* ]]; then
            local log_line="${line#data: }"

            # Try to extract timestamp and level for coloring
            local level
            level=$(echo "$log_line" | jq -r '.level // empty' 2>/dev/null) || true

            if [[ -n "$level" ]]; then
                local ts msg
                ts=$(echo "$log_line" | jq -r '.timestamp // ""' 2>/dev/null)
                msg=$(echo "$log_line" | jq -r '.message // ""' 2>/dev/null)

                case "$level" in
                    error)   echo -e "${C_DIM}${ts}${C_RESET} ${C_RED}ERR${C_RESET} ${msg}" ;;
                    warn*)   echo -e "${C_DIM}${ts}${C_RESET} ${C_YELLOW}WRN${C_RESET} ${msg}" ;;
                    info)    echo -e "${C_DIM}${ts}${C_RESET} ${C_BLUE}INF${C_RESET} ${msg}" ;;
                    debug)   echo -e "${C_DIM}${ts}${C_RESET} ${C_DIM}DBG${C_RESET} ${C_DIM}${msg}${C_RESET}" ;;
                    *)       echo -e "${C_DIM}${ts}${C_RESET} ${msg}" ;;
                esac
            else
                # Plain text log line
                echo "  $log_line"
            fi
        fi
    done
}

cmd_mailpit() {
    local action="${1:-}"

    case "$action" in
        on|start)
            check_daemon
            info "Starting Mailpit..."
            local result
            result=$(api POST /services/mailpit/start)
            success "Mailpit is running"
            echo -e "  ${ICON_ARROW} SMTP:  ${C_BOLD}127.0.0.1:1025${C_RESET}"
            echo -e "  ${ICON_ARROW} Web:   ${C_BOLD_CYAN}http://127.0.0.1:8025${C_RESET}"
            ;;
        off|stop)
            check_daemon
            info "Stopping Mailpit..."
            api POST /services/mailpit/stop >/dev/null
            success "Mailpit stopped"
            ;;
        status)
            check_daemon
            local result
            result=$(api GET /services/mailpit/status)
            local status
            status=$(echo "$result" | jq -r '.data.status // "unknown"' 2>/dev/null)
            echo -e "  Mailpit  $(status_icon "$status") ${status}"
            if [[ "$status" == "running" ]]; then
                echo -e "  ${ICON_ARROW} SMTP:  ${C_BOLD}127.0.0.1:1025${C_RESET}"
                echo -e "  ${ICON_ARROW} Web:   ${C_BOLD_CYAN}http://127.0.0.1:8025${C_RESET}"
            fi
            ;;
        open)
            info "Opening Mailpit in browser..."
            xdg-open "http://127.0.0.1:8025" 2>/dev/null || \
                echo -e "  ${ICON_ARROW} ${C_BOLD_CYAN}http://127.0.0.1:8025${C_RESET}"
            ;;
        *)
            echo -e "Usage: lantern mailpit <on|off|status|open>"
            echo ""
            echo -e "  ${C_BOLD}on${C_RESET}      Start Mailpit service"
            echo -e "  ${C_BOLD}off${C_RESET}     Stop Mailpit service"
            echo -e "  ${C_BOLD}status${C_RESET}  Show Mailpit status"
            echo -e "  ${C_BOLD}open${C_RESET}    Open Mailpit web UI in browser"
            ;;
    esac
}

cmd_services() {
    check_daemon

    local result
    result=$(api GET /services)

    echo ""
    echo -e "  ${C_BOLD}Services${C_RESET}"
    echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"
    echo ""

    echo "$result" | jq -r '.data[]? | "\(.name)\t\(.status)\t\(.ports // "—")\t\(.url // "—")"' 2>/dev/null | \
    while IFS=$'\t' read -r name status ports url; do
        local icon
        icon=$(status_icon "$status")
        printf "  %b  %-14s %b%-10s%b" "$icon" "$name" "$C_DIM" "$status" "$C_RESET"
        if [[ "$url" != "—" && "$url" != "null" ]]; then
            printf "  %b%s%b" "$C_CYAN" "$url" "$C_RESET"
        fi
        echo ""
    done

    echo ""
}

cmd_health() {
    check_daemon

    local result
    result=$(api GET /system/health)

    echo ""
    echo -e "  ${C_BOLD}System Health${C_RESET}"
    echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"
    echo ""

    # Iterate over health components
    echo "$result" | jq -r '.data | to_entries[]? | "\(.key)\t\(.value.status // "unknown")\t\(.value.message // "")"' 2>/dev/null | \
    while IFS=$'\t' read -r component status message; do
        local icon
        icon=$(status_icon "$status")
        printf "  %b  %-14s %b" "$icon" "$component" ""
        if [[ -n "$message" && "$message" != "null" ]]; then
            echo -e "${C_DIM}${message}${C_RESET}"
        else
            echo ""
        fi
    done

    # Daemon info
    local daemon_uptime
    daemon_uptime=$(echo "$result" | jq -r '.data.daemon.uptime // empty' 2>/dev/null) || true
    if [[ -n "$daemon_uptime" ]]; then
        echo ""
        echo -e "  ${C_DIM}Daemon uptime: ${daemon_uptime}${C_RESET}"
    fi

    echo ""
}

cmd_config() {
    local action="${1:-show}"

    check_daemon

    case "$action" in
        show|"")
            local result
            result=$(api GET /system/settings)

            echo ""
            echo -e "  ${C_BOLD}Settings${C_RESET}"
            echo -e "  ${C_DIM}$(printf '%.0s─' {1..50})${C_RESET}"
            echo ""

            echo "$result" | jq -r '.data | to_entries[]? | "\(.key)\t\(.value)"' 2>/dev/null | \
            while IFS=$'\t' read -r key value; do
                printf "  %-24s %s\n" "${key}" "${value}"
            done

            echo ""
            ;;
        set)
            local key="${2:-}"
            local value="${3:-}"
            if [[ -z "$key" || -z "$value" ]]; then
                die "Usage: lantern config set <key> <value>"
            fi
            local payload
            payload=$(jq -n --arg k "$key" --arg v "$value" '{($k): $v}')
            api PUT /system/settings "$payload" >/dev/null
            success "Set ${C_BOLD}${key}${C_RESET} = ${value}"
            ;;
        *)
            echo -e "Usage: lantern config [show|set <key> <value>]"
            ;;
    esac
}

cmd_open() {
    local name="${1:-}"
    if [[ -z "$name" ]]; then
        die "Usage: lantern open <project-name>"
    fi

    check_daemon

    local result
    result=$(api_quiet GET "/projects/${name}") || die "Project '${name}' not found"

    local domain
    domain=$(echo "$result" | jq -r '.data.domain // empty' 2>/dev/null)

    if [[ -z "$domain" ]]; then
        die "Could not determine domain for '${name}'"
    fi

    info "Opening ${C_BOLD_CYAN}https://${domain}${C_RESET} in browser..."
    xdg-open "https://${domain}" 2>/dev/null || \
        echo -e "  ${ICON_ARROW} ${C_BOLD_CYAN}https://${domain}${C_RESET}"
}

cmd_help() {
    echo ""
    echo -e "  ${C_BOLD}Lantern${C_RESET} v${LANTERN_VERSION}  ${C_DIM}— Valet for Linux${C_RESET}"
    echo ""
    echo -e "  ${C_BOLD}Usage:${C_RESET} lantern <command> [arguments]"
    echo ""
    echo -e "  ${C_BOLD}Setup${C_RESET}"
    echo -e "    init                Run one-time system setup (DNS, Caddy, TLS)"
    echo -e "    scan                Scan workspace for projects"
    echo -e "    health              Show system health status"
    echo ""
    echo -e "  ${C_BOLD}Projects${C_RESET}"
    echo -e "    list                List all projects"
    echo -e "    on <name>           Activate a project (start dev server + routing)"
    echo -e "    off <name>          Deactivate a project"
    echo -e "    restart <name>      Restart a project's dev server"
    echo -e "    status [name]       Show status (all projects or one)"
    echo -e "    logs <name>         Tail a project's log output"
    echo -e "    open <name>         Open project URL in browser"
    echo ""
    echo -e "  ${C_BOLD}Services${C_RESET}"
    echo -e "    services            List all services and their status"
    echo -e "    mailpit <on|off>    Start or stop Mailpit"
    echo -e "    mailpit status      Show Mailpit status"
    echo -e "    mailpit open        Open Mailpit web UI"
    echo ""
    echo -e "  ${C_BOLD}Config${C_RESET}"
    echo -e "    config              Show current settings"
    echo -e "    config set <k> <v>  Update a setting"
    echo ""
    echo -e "  ${C_BOLD}Other${C_RESET}"
    echo -e "    help                Show this help message"
    echo -e "    version             Show version"
    echo -e "    completions         Output shell completion script"
    echo ""
    echo -e "  ${C_DIM}Daemon: ${LANTERN_HOST}${C_RESET}"
    echo -e "  ${C_DIM}Override with LANTERN_HOST env var${C_RESET}"
    echo ""
}

cmd_version() {
    echo -e "Lantern ${C_BOLD}v${LANTERN_VERSION}${C_RESET}"
}

cmd_completions() {
    local shell="${1:-bash}"

    case "$shell" in
        bash)
            cat_bash_completions
            ;;
        zsh)
            cat_zsh_completions
            ;;
        fish)
            cat_fish_completions
            ;;
        *)
            echo "Usage: lantern completions <bash|zsh|fish>"
            echo ""
            echo "Add to your shell config:"
            echo "  bash:  eval \"\$(lantern completions bash)\""
            echo "  zsh:   eval \"\$(lantern completions zsh)\""
            echo "  fish:  lantern completions fish | source"
            ;;
    esac
}

# ---------------------------------------------------------------------------
# Formatting helpers
# ---------------------------------------------------------------------------

status_icon() {
    case "${1:-}" in
        ok|running|healthy|active)  echo -e "$ICON_OK" ;;
        error|failed|unhealthy)     echo -e "$ICON_ERR" ;;
        warn*|degraded)             echo -e "$ICON_WARN" ;;
        stopped|inactive|off)       echo -e "$ICON_OFF" ;;
        starting|stopping)          echo -e "$ICON_SPIN" ;;
        *)                          echo -e "$ICON_OFF" ;;
    esac
}

type_badge() {
    case "${1:-}" in
        php)     echo -e "${C_MAGENTA}php${C_RESET}" ;;
        proxy)   echo -e "${C_BLUE}proxy${C_RESET}" ;;
        static)  echo -e "${C_GREEN}static${C_RESET}" ;;
        *)       echo -e "${C_DIM}${1:-unknown}${C_RESET}" ;;
    esac
}

# ---------------------------------------------------------------------------
# Shell completions
# ---------------------------------------------------------------------------

cat_bash_completions() {
    cat << 'BASH_COMP'
_lantern_completions() {
    local cur prev commands project_commands
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    commands="init scan list on off restart status logs open mailpit services health config help version completions"
    project_commands="on off restart status logs open"
    mailpit_actions="on off start stop status open"

    case "$prev" in
        lantern)
            COMPREPLY=( $(compgen -W "$commands" -- "$cur") )
            return 0
            ;;
        on|off|restart|logs|open)
            # Complete with project names from the daemon
            local projects
            projects=$(curl -s "${LANTERN_HOST:-http://127.0.0.1:4777}/api/projects" 2>/dev/null | \
                jq -r '.data[]?.name' 2>/dev/null) || projects=""
            COMPREPLY=( $(compgen -W "$projects" -- "$cur") )
            return 0
            ;;
        status)
            # Can optionally take a project name
            local projects
            projects=$(curl -s "${LANTERN_HOST:-http://127.0.0.1:4777}/api/projects" 2>/dev/null | \
                jq -r '.data[]?.name' 2>/dev/null) || projects=""
            COMPREPLY=( $(compgen -W "$projects" -- "$cur") )
            return 0
            ;;
        mailpit)
            COMPREPLY=( $(compgen -W "$mailpit_actions" -- "$cur") )
            return 0
            ;;
        config)
            COMPREPLY=( $(compgen -W "show set" -- "$cur") )
            return 0
            ;;
        completions)
            COMPREPLY=( $(compgen -W "bash zsh fish" -- "$cur") )
            return 0
            ;;
    esac

    return 0
}
complete -F _lantern_completions lantern
BASH_COMP
}

cat_zsh_completions() {
    cat << 'ZSH_COMP'
#compdef lantern

_lantern_get_projects() {
    local projects
    projects=($(curl -s "${LANTERN_HOST:-http://127.0.0.1:4777}/api/projects" 2>/dev/null | \
        jq -r '.data[]?.name' 2>/dev/null))
    _describe 'projects' projects
}

_lantern() {
    local -a commands
    commands=(
        'init:Run one-time system setup'
        'scan:Scan workspace for projects'
        'list:List all projects'
        'on:Activate a project'
        'off:Deactivate a project'
        'restart:Restart a project'
        'status:Show project status'
        'logs:Tail project logs'
        'open:Open project in browser'
        'mailpit:Manage Mailpit service'
        'services:List all services'
        'health:Show system health'
        'config:Show or update settings'
        'help:Show help'
        'version:Show version'
        'completions:Output shell completions'
    )

    _arguments -C \
        '1: :->command' \
        '*:: :->args'

    case $state in
        command)
            _describe 'commands' commands
            ;;
        args)
            case ${words[1]} in
                on|off|restart|logs|open|status)
                    _lantern_get_projects
                    ;;
                mailpit)
                    local -a actions
                    actions=('on:Start Mailpit' 'off:Stop Mailpit' 'status:Show status' 'open:Open web UI')
                    _describe 'actions' actions
                    ;;
                config)
                    local -a config_cmds
                    config_cmds=('show:Show settings' 'set:Update a setting')
                    _describe 'config commands' config_cmds
                    ;;
                completions)
                    local -a shells
                    shells=('bash' 'zsh' 'fish')
                    _describe 'shells' shells
                    ;;
            esac
            ;;
    esac
}

_lantern "$@"
ZSH_COMP
}

cat_fish_completions() {
    cat << 'FISH_COMP'
# Fish completions for Lantern

function __lantern_projects
    curl -s "$LANTERN_HOST/api/projects" 2>/dev/null | jq -r '.data[]?.name' 2>/dev/null; or true
end

# Disable file completions
complete -c lantern -f

# Top-level commands
complete -c lantern -n "__fish_use_subcommand" -a init -d "Run one-time system setup"
complete -c lantern -n "__fish_use_subcommand" -a scan -d "Scan workspace for projects"
complete -c lantern -n "__fish_use_subcommand" -a list -d "List all projects"
complete -c lantern -n "__fish_use_subcommand" -a on -d "Activate a project"
complete -c lantern -n "__fish_use_subcommand" -a off -d "Deactivate a project"
complete -c lantern -n "__fish_use_subcommand" -a restart -d "Restart a project"
complete -c lantern -n "__fish_use_subcommand" -a status -d "Show project status"
complete -c lantern -n "__fish_use_subcommand" -a logs -d "Tail project logs"
complete -c lantern -n "__fish_use_subcommand" -a open -d "Open project in browser"
complete -c lantern -n "__fish_use_subcommand" -a mailpit -d "Manage Mailpit service"
complete -c lantern -n "__fish_use_subcommand" -a services -d "List all services"
complete -c lantern -n "__fish_use_subcommand" -a health -d "Show system health"
complete -c lantern -n "__fish_use_subcommand" -a config -d "Show or update settings"
complete -c lantern -n "__fish_use_subcommand" -a help -d "Show help"
complete -c lantern -n "__fish_use_subcommand" -a version -d "Show version"
complete -c lantern -n "__fish_use_subcommand" -a completions -d "Output shell completions"

# Project name completions
complete -c lantern -n "__fish_seen_subcommand_from on off restart status logs open" -a "(__lantern_projects)"

# Mailpit subcommands
complete -c lantern -n "__fish_seen_subcommand_from mailpit" -a "on off status open"

# Config subcommands
complete -c lantern -n "__fish_seen_subcommand_from config" -a "show set"

# Completions subcommands
complete -c lantern -n "__fish_seen_subcommand_from completions" -a "bash zsh fish"
FISH_COMP
}

# ---------------------------------------------------------------------------
# Command dispatch
# ---------------------------------------------------------------------------

main() {
    local cmd="${1:-help}"
    shift 2>/dev/null || true

    case "$cmd" in
        init)           cmd_init "$@" ;;
        scan)           cmd_scan "$@" ;;
        list|ls)        cmd_list "$@" ;;
        on|activate)    cmd_on "$@" ;;
        off|deactivate) cmd_off "$@" ;;
        restart)        cmd_restart "$@" ;;
        status|st)      cmd_status "$@" ;;
        logs|log)       cmd_logs "$@" ;;
        mailpit|mail)   cmd_mailpit "$@" ;;
        services|svc)   cmd_services "$@" ;;
        health)         cmd_health "$@" ;;
        config|cfg)     cmd_config "$@" ;;
        open)           cmd_open "$@" ;;
        help|-h|--help) cmd_help "$@" ;;
        version|-v|--version) cmd_version "$@" ;;
        completions)    cmd_completions "$@" ;;
        *)
            error "Unknown command: ${cmd}"
            echo ""
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
